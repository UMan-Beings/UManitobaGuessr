name: ci pipeline

on:
  push:
    branches: main
  pull_request:
    branches: main
  workflow_dispatch:

jobs:
  test-build-backend:
    runs-on: ubuntu-latest

    # use temporary containers for testing
    services:
      postgres:
        image: postgres:latest
        env:
          POSTGRES_USER: myuser
          POSTGRES_PASSWORD: secret
          POSTGRES_DB: mydatabase
        ports:
          - 5432:5432
        options: >-
          --health-cmd="pg_isready"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=5

    steps:
      # step 1: checkout repository
      - name: checkout repository
        uses: actions/checkout@v4

      # step 2: set up java 21
      - name: set up java
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: 21

      # step 3: make gradle wrapper executable
      - name: make gradlew executable
        working-directory: backend
        run: chmod +x gradlew

      # step 4: cache gradle dependencies, and back 
      - name: cache gradle
        uses: actions/cache@v3
        with:
          path: |
            ~/.gradle/caches
            ~/.gradle/wrapper/
          key: ${{ runner.os }}-gradle-${{ hashFiles('backend/**/*.gradle*', 'backend/gradle/wrapper/gradle-wrapper.properties') }}
          restore-keys: |
            ${{ runner.os }}-gradle-${{ hashFiles('backend/gradle.properties') }}-
            ${{ runner.os }}-gradle-

      # step 5: start docker compose services (postgres + backend)
      # -d container runs in detattached mode (logs wont show in terminal), up
      - name: start docker compose
        run: docker compose up --build -d

      # step 6: wait for postgres to be ready
      # exec runs command inside existing backend container
      - name: wait for postgres
        run: |
          until docker compose exec -T postgres pg_isready; do
            echo "waiting for postgres..."
            sleep 2
          done

      # step 7: run backend tests inside backend container
      - name: run backend tests
        run: docker compose exec -T backend ./gradlew test

      #### INCLUDE THIS IF we want pr suggestsions in the CI
      # step 8: run sonarcloud analysis
      # - name: run sonarcloud scan
      #   uses: SonarSource/sonarcloud-github-action@master
      #   with:
      #     projectKey: your_project_key
      #     organization: your_organization
      #   env:
      #     SONAR_TOKEN: ${{secrets.SONAR_TOKEN}}

      # step 9: stop and remove containers after testing
      # -v remove volumes 
      - name: teardown docker compose
        run: docker compose down -v

      # step 10: build backend jar inside container, skip tests
      # --rm remove container
      - name: build backend jar
        run: docker compose run --rm backend ./gradlew build -x test

      # step 11: upload backend jar as artifact for next job
      - name: upload backend jar
        uses: actions/upload-artifact@v3
        with:
          name: tested-backend-jar
          path: backend/build/libs/*.jar

  build-backend-image:
    runs-on: ubuntu-latest
    needs: test-build-backend

    steps:
      # step 1: checkout repository
      - name: checkout repository
        uses: actions/checkout@v4

      # step 2: download backend jar from previous job
      - name: download backend jar
        uses: actions/download-artifact@v3
        with:
          name: tested-backend-jar
          path: backend/build/libs/

      # step 3: build backend docker image
      - name: build backend docker image
        run: |
          IMAGE_TAG=${GITHUB_SHA::8}  # use first 8 chars of commit SHA as unique tag
          docker compose build backend
          docker tag springboot-backend:latest springboot-backend:$IMAGE_TAG
          docker tag springboot-backend:latest springboot-backend:latest

      # step 4: save backend image as artifact
      - name: save backend docker image
        run: docker save springboot-backend:latest -o backend-image.tar

      # step 5: upload docker image artifact
      - name: upload backend docker image
        uses: actions/upload-artifact@v3
        with:
          name: backend-docker-image
          path: backend-image.tar

  push-backend-image:
    runs-on: ubuntu-latest
    needs: build-backend-image

    steps:
      # step 1: checkout repository
      - name: checkout repository
        uses: actions/checkout@v4

      # step 2: download docker image artifact
      - name: download docker image artifact
        uses: actions/download-artifact@v3
        with:
          name: backend-docker-image
          path: backend-image.tar

      # step 3: load docker image
      - name: load docker image
        run: docker load -i backend-image.tar

      # step 4: login to github container registry
      - name: log in to ghcr
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # step 5: tag docker image for ghcr
      # Gives each docker image a unique SHA, and keeps the latest tag
      - name: tag docker image
        run: |
          IMAGE_TAG=${GITHUB_SHA::8}  # match SHA tag
          docker tag springboot-backend:latest ghcr.io/${{ github.repository_owner }}/springboot-backend:$IMAGE_TAG
          docker tag springboot-backend:latest ghcr.io/${{ github.repository_owner }}/springboot-backend:latest

      # step 6: push docker image to ghcr
      - name: push docker image
        run: |
          IMAGE_TAG=${GITHUB_SHA::8}  # match SHA tag
          docker push ghcr.io/${{ github.repository_owner }}/springboot-backend:$IMAGE_TAG
          docker push ghcr.io/${{ github.repository_owner }}/springboot-backend:latest
